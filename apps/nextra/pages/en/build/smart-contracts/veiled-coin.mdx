---
title: "Veiled Coin"
id: "veiled-coin"
---

import { Callout } from "nextra/components";
import { ThemedImage } from "@components/index";

# Aptos Veiled Coin (VC) Standard

The Veiled Coin Standard (also known as "Veiled Coin" or "VC") is a privacy-focused protocol for managing Fungible Assets (FA).
It allows users to perform transactions with hidden FA amounts while keeping sender and recipient addresses publicly visible.

The standard allows any FA to be wrapped into a corresponding Veiled Coin, ensuring compatibility with existing tokens.
Similar to FA, 64-bit transfers are supported, and balances of up to 128 bits.

Operations on Veiled Coin balances (veiled balances), require zero-knowledge proofs (ZKPs) to verify transaction correctness
without revealing hidden amounts and other sensitive data.

<Callout type="info">
  Interacting directly with Veiled Coin's smart contracts is highly complex.
  Developers are encouraged to create external services to manage tasks like generating ZKPs, recovering keys, and decrypting balances.
  To assist with this, we've developed a TypeScript SDK, with full documentation available [here](https://).
</Callout>

<Callout type="info">
  This documentation explains the contract's operations and offers insights into the protocol core processes.
  Cryptographic and math details are explained superficially but more in-depth information can be found [here](https://).
</Callout>

## Veiled Coin Store

For every veiled coin a user registers, they generate a unique key pair:
- An encryption key (EK) stored on-chain.
- A decryption key (DK) kept securely by the user.

These keys are standalone and should not be confused with the Aptos account's public and private keys.

Each veiled balance is split into two parts:
- `pending_balance` - accumulates all incoming transactions.
- `actual_balance` - used exclusively for outgoing transactions.

Both balances are encrypted with the same user's EK, ensuring underlying amounts remain private.

<Callout type="info">
  This separation protects against "front-running" attacks.
  Specifically, if there was a single balance, an attacker could revert a user's transaction by sending a small veiled payment,
  altering the balance and, consequently, invalidating the user's ZKP.
</Callout>

The veiled balance and its associated encryption key are stored in the `VeiledCoinStore` resource.
The `VeiledCoinStore` is instantiated for each veiled coin the user has and managed by the `veiled_coin` module:

```move filename="veiled_coin.move"
struct VeiledCoinStore has key {
    pending_balance: veiled_balance::CompressedVeiledBalance,
    actual_balance: veiled_balance::CompressedVeiledBalance,
    ek: twisted_elgamal::CompressedPubkey,
    // ...
}
```

## Veiled Balance

Veiled balances handle token amounts by splitting them into smaller, encrypted units called chunks.
Each chunk represents a portion of the total value and is encrypted individually using the user’s EK.
This design supports efficient management of balances.

### Chunks

The pending balance consists of two chunks that temporarily hold incoming transfers.
It can handle up to 2^16 incoming 64-bit transfers before requiring a rollover to the actual balance.
During this accumulation, the pending balance chunks can grow to 48 bits.

The actual balance consists of four chunks, supporting up to 128-bit values.
After any operation, except rollover, the actual balance is normalized back to 32 bits per chunk to maintain
efficient decryption.

The `VeiledBalance` struct from the `veiled_balance` module is used to represent both pending and actual balances:

```move filename="veiled_coin.move"
struct VeiledBalance has drop {
    chunks: vector<twisted_elgamal::Ciphertext>,
}
```

### Encryption and Decryption

When a balance is encrypted:

- The total amount is split into 32-bit chunks.
- Each chunk is encrypted individually with the user's EK.

Decryption involves:

- Applying the user’s DK to decrypt each chunk.
- Solving a discrete logarithm (DL) problem for each chunk to recover the original values.
- Combining the recovered values to reconstruct the total amount.

### Normalization

Normalization ensures chunks are always reduced to manageable sizes (32 bits).
Without normalization, chunks can grow too large, making the decryption process (solving DL) significantly slower or even impractical.
This mechanism is automatically applied to the actual balance after every operation,
so that users can always decrypt their balances, even as balances grow through multiple transactions.

### Homomorphic Encryption

Veiled balances utilize homomorphic encryption, allowing encrypted values to be added or subtracted without decryption.
This capability is essential for updating the receiver's pending balance during transfers and for performing rollover
operations, where the pending balance is added to the actual balance.

## Architecture

- Add scheme and small description

## Entry functions

### Register

```move filename="veiled_coin.move"
public entry fun register(sender: &signer, token: Object<Metadata>, ek: vector<u8>)
```

Users must register a `VeiledCoinStore` for each token they intend to transact with.
As part of this process, users are required to generate a key pair (EK and DK) on their end.

When a `VeiledCoinStore` is first registered, the veiled balance is set to zero,
represented as zero ciphertexts for both the `pending_balance` and `actual_balance`.

<Callout type="info">
  Although it is recommended to generate a unique key pair for each token to enhance security,
  it's not restricted to reuse the same encryption key across multiple tokens if preferred.
</Callout>
<Callout type="warning">
  This operation is expensive as it initializes a new storage and storage fees far exceed execution fees.
  However, users call it only once per token.
</Callout>

```move filename="register_example.move"
#[test_only]
module veiled_coin_addr::register_example {
    /// ...

    fun register(bob: &signer, token: Object<Metadata>) {
        let bob_addr = signer::address_of(bob);

        // It's a test-only function, so we don't need to worry about the security of the key pair.
        let (_bob_dk, bob_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();

        let bob_ek = twisted_elgamal::pubkey_to_bytes(&bob_ek);

        veiled_coin::register(bob, token, bob_ek);

        print(&utf8(b"Bob's pending balance is a zero ciphertext:"));
        print(&veiled_coin::pending_balance(bob_addr, token));

        print(&utf8(b"Bob's actual balance is a zero ciphertext:"));
        print(&veiled_coin::actual_balance(bob_addr, token));

        print(&utf8(b"Bob's encryption key is set:"));
        print(&veiled_coin::encryption_key(bob_addr, token));
    }
}
```

### Veil

```move filename="veiled_coin.move"
public entry fun veil(sender: &signer, token: Object<Metadata>, amount: u64)
```
```move filename="veiled_coin.move"
public entry fun veil_to(sender: &signer, token: Object<Metadata>, to: address, amount: u64)
```

The `veil` and `veil_to` functions bring tokens into the protocol, transferring the passed amount
from primary FA store of the sender to the pending balance of the recipient.

The amount in this function is publicly visible, as adding new tokens to the protocol requires a normal transfer.
However, tokens within the protocol become obfuscated through veiled transfers, ensuring privacy in subsequent transactions.

<Callout type="info">
  If you want to have a veiled amount from the beginning, use the `fully_veiled_transfer` function instead.
</Callout>

```move filename="veil_example.move"
#[test_only]
module veiled_coin_addr::veil_example {
    /// ...

    fun veil(bob: &signer, alice: &signer, token: Object<Metadata>) {
        let bob_addr = signer::address_of(bob);
        let alice_addr = signer::address_of(alice);

        // It's a test-only function, so we don't need to worry about the security of the keypair.
        let (bob_dk, bob_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();
        let (alice_dk, alice_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();

        let bob_ek = twisted_elgamal::pubkey_to_bytes(&bob_ek);
        let alice_ek = twisted_elgamal::pubkey_to_bytes(&alice_ek);

        veiled_coin::register(bob, token, bob_ek);
        veiled_coin::register(alice, token, alice_ek);

        print(&utf8(b"Bob's FA balance before the veil is 500:"));
        print(&primary_fungible_store::balance(bob_addr, token));

        let bob_amount = 100;
        let alice_amount = 200;

        // The balance is not veiled yet, because we explicitly pass the amount to the function.
        veiled_coin::veil(bob, token, bob_amount);
        veiled_coin::veil_to(bob, token, alice_addr, alice_amount);

        print(&utf8(b"Bob's FA balance after the veil is 200:"));
        print(&primary_fungible_store::balance(bob_addr, token));

        print(&utf8(b"Bob's pending balance is not zero:"));
        print(&veiled_coin::pending_balance(bob_addr, token));

        // In real world, we would not be able to see the someone else's balance as it requires
        // the knowledge of the decryption key.
        // The balance decryption requires solving the discrete logarithm problem,
        // so we just check if the passed amount is correct for simplicity.
        assert!(veiled_coin::verify_pending_balance(bob_addr, token, &bob_dk, bob_amount));

        print(&utf8(b"Alice's pending balance is not zero:"));
        print(&veiled_coin::pending_balance(alice_addr, token));

        assert!(veiled_coin::verify_pending_balance(alice_addr, token, &alice_dk, alice_amount));
    }
}
```

### Rollover Pending Balance

```move filename="veiled_coin.move"
public entry fun rollover_pending_balance(sender: &signer, token: Object<Metadata>)
```

The `rollover_pending_balance` function "merges" the pending balance into the actual one, resetting the pending balance to zero.
This works because of the [Homomorphic encryption](#homomorphic-encryption) used in the protocol.
Before spending from the pending balance, the user must call this function in a separate transaction.

<Callout type="warning">
Calling the `rollover_pending_balance` function in a separate transaction is crucial for preventing ["front-running" attacks](#veiled-coin-store).
</Callout>

```move filename="rollover_example.move"
#[test_only]
module veiled_coin_addr::rollover_example {
    /// ...

    fun rollover(bob: &signer, token: Object<Metadata>) {
        let bob_addr = signer::address_of(bob);

        // It's a test-only function, so we don't need to worry about the security of the keypair.
        let (bob_dk, bob_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();

        let bob_ek = twisted_elgamal::pubkey_to_bytes(&bob_ek);

        veiled_coin::register(bob, token, bob_ek);

        veiled_coin::veil(bob, token, 100);

        print(&utf8(b"Bob's pending balance is NOT zero:"));
        print(&veiled_coin::pending_balance(bob_addr, token));

        print(&utf8(b"Bob's actual balance is zero:"));
        print(&veiled_coin::actual_balance(bob_addr, token));

        assert!(veiled_coin::verify_pending_balance(bob_addr, token, &bob_dk, 100));
        assert!(veiled_coin::verify_actual_balance(bob_addr, token, &bob_dk, 0));

        veiled_coin::rollover_pending_balance(bob, token);

        print(&utf8(b"Bob's pending balance is zero:"));
        print(&veiled_coin::pending_balance(bob_addr, token));

        print(&utf8(b"Bob's actual balance is NOT zero:"));
        print(&veiled_coin::actual_balance(bob_addr, token));

        assert!(veiled_coin::verify_pending_balance(bob_addr, token, &bob_dk, 0));
        assert!(veiled_coin::verify_actual_balance(bob_addr, token, &bob_dk, 100));
    }
}
```

### Fully Veiled Transfer

```move filename="veiled_coin.move"
public entry fun fully_veiled_transfer(
    sender: &signer,
    token: Object<Metadata>,
    to: address,
    new_balance: vector<u8>,
    transfer_balance: vector<u8>,
    auditor_eks: vector<u8>,
    auditor_balances: vector<u8>,
    zkrp_new_balance: vector<vector<u8>>,
    zkrp_transfer_balance: vector<vector<u8>>,
    sigma_proof: vector<u8>)
```

The `fully_veiled_transfer` function transfers tokens from the sender's actual balance to the recipient's
pending balance. The sender encrypts the transferred amount using the recipient's encryption key, enabling the recipient's
veiled balance to be updated [homomorphically](#homomorphic-encryption).

To ensure transparency, the sender also encrypts the transferred amount using the auditors' encryption keys,
allowing the auditors to decrypt and verify the transferred amount.

Finally, the sender provides their updated normalized actual veiled balance, encrypted with fresh randomness to maintain privacy.

<Callout type="info">
  Once a user has participated in at least one transfer, their balance becomes "veiled".
  This means that neither the transferred amount nor the updated balances of the sender and recipient are visible to external observers.
</Callout>

```move filename="transfer_example.move"
#[test_only]
module veiled_coin_addr::transfer_example {
    /// ...

    fun transfer(global_auditor: &signer, bob: &signer, alice: &signer, token: Object<Metadata>) {
        let bob_addr = signer::address_of(bob);
        let alice_addr = signer::address_of(alice);

        // It's a test-only function, so we don't need to worry about the security of the keypair.
        let (bob_dk, bob_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();
        let (alice_dk, alice_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();

        // Note: If the global auditor is set, we need to include it in the `auditor_eks` vector as the FIRST element.
        // It is not implemented in this example, but you can uncomment the code below to set the global auditor and
        // include it into the `auditor_eks` list.
        //
        // let (_global_auditor_dk, global_auditor_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();
        // let global_auditor_ek_bytes = twisted_elgamal::pubkey_to_bytes(&global_auditor_ek);
        //
        // veiled_coin::set_auditor(global_auditor, signer::address_of(global_auditor), global_auditor_ek_bytes);
        //
        // let (_, global_auditor_ek) = veiled_coin::get_auditor();
        // let auditor_eks = vector![global_auditor_ek.extract()];

        let (_, auditor_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();
        let auditor_eks = vector[auditor_ek];

        let bob_ek_bytes = twisted_elgamal::pubkey_to_bytes(&bob_ek);
        let alice_ek_bytes = twisted_elgamal::pubkey_to_bytes(&alice_ek);

        veiled_coin::register(bob, token, bob_ek_bytes);
        veiled_coin::register(alice, token, alice_ek_bytes);

        // Bob's current balance is 300, and he wants to transfer 50 to Alice, whose balance is zero.
        let bob_current_amount = 300;
        let bob_new_amount = 250;
        let transfer_amount = 50;
        let alice_current_amount = 0;
        let alice_new_amount = 50;

        veiled_coin::veil(bob, token, bob_current_amount);
        veiled_coin::rollover_pending_balance(bob, token);

        print(&utf8(b"Bob's actual balance is 300"));
        assert!(veiled_coin::verify_actual_balance(bob_addr, token, &bob_dk, (bob_current_amount as u128)));

        print(&utf8(b"Alice's pending balance is zero"));
        assert!(veiled_coin::verify_pending_balance(alice_addr, token, &alice_dk, alice_current_amount));

        let current_balance = veiled_balance::decompress_balance(&veiled_coin::actual_balance(bob_addr, token));

        let (
            proof,
            // New balance is the balance after the transfer encrypted with the sender's encryption key.
            // It will be set as the new actual balance for the sender.
            new_balance,
            // Transfer balance is a transfer amount encrypted with the recipient's encryption key.
            // It will be Homomorphically added to the recipient's pending balance.
            transfer_balance,
            // Auditor balance is the transfer amount encrypted with the auditor's encryption key.
            // It won't be stored on-chain, but an auditor can decrypt the transfer amount with its dk.
            auditor_balances
        ) = veiled_proof::prove_transfer(
            &bob_dk,
            &bob_ek,
            &alice_ek,
            transfer_amount,
            bob_new_amount,
            &current_balance,
            &auditor_eks,
        );

        let (
            sigma_proof,
            zkrp_new_balance,
            zkrp_transfer_balance
        ) = veiled_proof::serialize_transfer_proof(&proof);

        veiled_coin::fully_veiled_transfer(
            bob,
            token,
            alice_addr,
            veiled_balance::balance_to_bytes(&new_balance),
            veiled_balance::balance_to_bytes(&transfer_balance),
            veiled_coin::serialize_auditor_eks(&auditor_eks),
            veiled_coin::serialize_auditor_balances(&auditor_balances),
            zkrp_new_balance,
            zkrp_transfer_balance,
            sigma_proof
        );

        print(&utf8(b"Bob's actual balance is 250"));
        assert!(veiled_coin::verify_actual_balance(bob_addr, token, &bob_dk, bob_new_amount));

        print(&utf8(b"Alice's pending balance is 50"));
        assert!(veiled_coin::verify_pending_balance(alice_addr, token, &alice_dk, alice_new_amount));
    }
}
```

### Unveil

```move filename="veiled_coin.move"
public entry fun unveil(
    sender: &signer,
    token: Object<Metadata>,
    amount: u64,
    new_balance: vector<u8>,
    zkrp_new_balance: vector<vector<u8>>,
    sigma_proof: vector<u8>)
```
```move filename="veiled_coin.move"
public entry fun unveil_to(
    sender: &signer,
    token: Object<Metadata>,
    to: address,
    amount: u64,
    new_balance: vector<u8>,
    zkrp_new_balance: vector<vector<u8>>,
    sigma_proof: vector<u8>)
```

The `unveil` and `unveil_to` allow a user to withdraw tokens from the protocol,
transferring the passed amount from the actual balance of the sender to the primary FA store of the recipient.
This function enables users to release tokens while not revealing their remaining balances.

<Callout type="warning">
  Attempting to unveil more tokens than available will cause an error.
</Callout>

```move filename="unveil_example.move"
#[test_only]
module veiled_coin_addr::unveil_example {
    /// ...

    fun unveil(bob: &signer, alice: &signer, token: Object<Metadata>) {
        let bob_addr = signer::address_of(bob);
        let alice_addr = signer::address_of(alice);

        // It's a test-only function, so we don't need to worry about the security of the keypair.
        let (bob_dk, bob_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();
        let (_alice_dk, alice_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();

        let bob_ek_bytes = twisted_elgamal::pubkey_to_bytes(&bob_ek);
        let alice_ek_bytes = twisted_elgamal::pubkey_to_bytes(&alice_ek);

        veiled_coin::register(bob, token, bob_ek_bytes);
        veiled_coin::register(alice, token, alice_ek_bytes);

        let bob_current_amount = 500;
        let bob_new_amount = 450;
        let transfer_amount = 50;

        // Bob veils all available tokens
        veiled_coin::veil(bob, token, (bob_current_amount as u64));
        veiled_coin::rollover_pending_balance(bob, token);

        print(&utf8(b"Alice's FA balance before the unveil is zero:"));
        print(&primary_fungible_store::balance(alice_addr, token));

        print(&utf8(b"Bob's actual balance before the unveil is 500"));
        assert!(veiled_coin::verify_actual_balance(bob_addr, token, &bob_dk, bob_current_amount));

        let current_balance = veiled_balance::decompress_balance(&veiled_coin::actual_balance(bob_addr, token));

        let (proof, new_balance) = veiled_proof::prove_withdrawal(
            &bob_dk,
            &bob_ek,
            transfer_amount,
            bob_new_amount,
            &current_balance
        );

        let new_balance = veiled_balance::balance_to_bytes(&new_balance);
        let (sigma_proof, zkrp_new_balance) = veiled_proof::serialize_withdrawal_proof(&proof);

        veiled_coin::unveil_to(bob, token, alice_addr, transfer_amount, new_balance, zkrp_new_balance, sigma_proof);

        print(&utf8(b"Alice's FA balance after the unveil is 50:"));
        print(&primary_fungible_store::balance(alice_addr, token));

        print(&utf8(b"Bob's actual balance after the veil is 450"));
        assert!(veiled_coin::verify_actual_balance(bob_addr, token, &bob_dk, bob_new_amount));
    }
}

```

### Rotate Encryption Key

```move filename="veiled_coin.move"
public entry fun rotate_encryption_key(
    sender: &signer,
    token: Object<Metadata>,
    new_ek: vector<u8>,
    new_balance: vector<u8>,
    zkrp_new_balance: vector<vector<u8>>,
    sigma_proof: vector<u8>)
```

```move filename="veiled_coin.move"
public entry fun rollover_pending_balance_and_freeze(sender: &signer, token: Object<Metadata>)
```

```move filename="veiled_coin.move"
public entry fun rotate_encryption_key_and_unfreeze(
    sender: &signer,
    token: Object<Metadata>,
    new_ek: vector<u8>,
    new_veiled_balance: vector<u8>,
    zkrp_new_balance: vector<vector<u8>>,
    rotate_proof: vector<u8>)
```

The `rotate_encryption_key` function modifies the user's EK and re-encrypts the actual balance with the new EK.
This function checks that the pending balance is zero before proceeding, guaranteeing that the user does not lose funds during the rotation.

To facilitate the rotation process:

- The pending balance must first be rolled over and frozen by calling `rollover_pending_balance_and_freeze`.
This prevents new transactions from being processed during the key rotation.
- Then the EK can be rotated and unfrozen using `rotate_encryption_key_and_unfreeze`.

<Callout type="warning">
  Calling `rotate_encryption_key` with a non-zero pending balance will cause an error.
</Callout>

```move filename="rotate_example.move"
#[test_only]
module veiled_coin_addr::rotate_example {
    /// ...

    fun rotate(bob: &signer, token: Object<Metadata>) {
        let bob_addr = signer::address_of(bob);

        // It's a test-only function, so we don't need to worry about the security of the keypair.
        let (bob_current_dk, bob_current_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();
        let (bob_new_dk, bob_new_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();

        let bob_current_ek_bytes = twisted_elgamal::pubkey_to_bytes(&bob_current_ek);
        let bob_new_ek_bytes = twisted_elgamal::pubkey_to_bytes(&bob_new_ek);

        let bob_amount = 100;

        veiled_coin::register(bob, token, bob_current_ek_bytes);
        veiled_coin::veil(bob, token, (bob_amount as u64));

        // We need to rollover the pending balance and freeze the token to prevent any new veiled deposits being come.
        veiled_coin::rollover_pending_balance_and_freeze(bob, token);

        print(&utf8(b"Bob's encryption key before the rotation:"));
        print(&veiled_coin::encryption_key(bob_addr, token));

        assert!(veiled_coin::verify_actual_balance(bob_addr, token, &bob_current_dk, bob_amount));

        let current_balance = veiled_balance::decompress_balance(&veiled_coin::actual_balance(bob_addr, token));

        let (proof, new_balance) = veiled_proof::prove_rotation(
            &bob_current_dk,
            &bob_new_dk,
            &bob_current_ek,
            &bob_new_ek,
            bob_amount,
            &current_balance
        );

        let (
            sigma_proof,
            zkrp_new_balance
        ) = veiled_proof::serialize_rotation_proof(&proof);

        // After rotating the encryption key, we unfreeze the token to allow new veiled deposits.
        veiled_coin::rotate_encryption_key_and_unfreeze(
            bob,
            token,
            bob_new_ek_bytes,
            veiled_balance::balance_to_bytes(&new_balance),
            zkrp_new_balance,
            sigma_proof
        );

        print(&utf8(b"Bob's encryption key after the rotation:"));
        print(&veiled_coin::encryption_key(bob_addr, token));

        // Note that here we use the new decryption key to verify the actual balance.
        assert!(veiled_coin::verify_actual_balance(bob_addr, token, &bob_new_dk, bob_amount));
    }
}

```

### Normalization

```move filename="veiled_coin.move"
public entry fun normalize(
    sender: &signer,
    token: Object<Metadata>,
    new_balance: vector<u8>,
    zkrp_new_balance: vector<vector<u8>>,
    sigma_proof: vector<u8>)
```

The `normalize` function ensures that the actual balance is reduced to 32-bit chunks for [efficient decryption](#normalization).
This is necessary only before the `rollover_pending_balance` operation, which requires the actual balance to be normalized beforehand.

All other functions, such as `unveil` or `fully_veiled_transfer`, handle normalization implicitly, making manual normalization unnecessary in those cases.

<Callout type="info">
  All functions except `rollover_pending_balance` perform implicit normalization.
</Callout>
<Callout type="warning">
  Attempting calling a `rollover_pending_balance` on an denormalized balance will cause an error.
</Callout>

```move filename="normalize_example.move"
#[test_only]
module veiled_coin_addr::normalize_example {
    /// ...

    fun normalize(bob: &signer, token: Object<Metadata>) {
        let bob_addr = signer::address_of(bob);

        // It's a test-only function, so we don't need to worry about the security of the keypair.
        let (bob_dk, bob_ek) = twisted_elgamal::generate_twisted_elgamal_keypair();

        let bob_ek_bytes = twisted_elgamal::pubkey_to_bytes(&bob_ek);

        let bob_amount = 500;

        veiled_coin::register(bob, token, bob_ek_bytes);
        veiled_coin::veil(bob, token, (bob_amount as u64));

        // The rollover function is the only function that requires the actual balance to be normalized
        // beforehand and leaves it unnormalized after execution, no matter what the pending balance was.
        veiled_coin::rollover_pending_balance(bob, token);

        assert!(!veiled_coin::is_normalized(bob_addr, token));

        veiled_coin::veil(bob, token, (bob_amount as u64));

        // Before performing a second rollover, the actual balance must be normalized.
        // You will get an error if you try to rollover an unnormalized balance:
        // veiled_coin::rollover_pending_balance(bob, token);

        let current_balance = veiled_balance::decompress_balance(&veiled_coin::actual_balance(bob_addr, token));

        let (
            proof,
            new_balance
        ) = veiled_proof::prove_normalization(
            &bob_dk,
            &bob_ek,
            bob_amount,
            &current_balance
        );

        let (sigma_proof, zkrp_new_balance) = veiled_proof::serialize_normalization_proof(&proof);

        veiled_coin::normalize(
            bob,
            token,
            veiled_balance::balance_to_bytes(&new_balance),
            zkrp_new_balance,
            sigma_proof
        );

        assert!(veiled_coin::is_normalized(bob_addr, token));
        assert!(veiled_coin::verify_actual_balance(bob_addr, token, &bob_dk, bob_amount));

        // A rollover can be performed once the balance is normalized.
        // Note that functions like `unveil` and `fully_veiled_transfer` do not require the actual balance
        // to be normalized beforehand, as zk-proofs guarantee that the actual balance is normalize after
        // their execution.
        veiled_coin::rollover_pending_balance(bob, token);
    }
}
```