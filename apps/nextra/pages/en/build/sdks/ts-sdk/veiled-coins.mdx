---
title: "Veiled Coins"
---

import { Callout } from 'nextra/components'

# Interact with Veiled Coins (VC) via the typescript SDK

You can use `veiledCoin` property of `Aptos` client to interact with `VC`

### Initialization

Operations in VC require generating zk-proofs (ZKPs), and depending on your environment, you need to define `Range Proof` calculation.

For the web, you could use `@distributedlab/aptos-wasm-bindings`:

```typescript
import initWasm, { range_proof as rangeProof, verify_proof as verifyProof } from "@distributedlab/aptos-wasm-bindings";

export interface RangeProofInputs {
  v: bigint;
  r: Uint8Array;
  valBase: Uint8Array;
  randBase: Uint8Array;
  bits?: number;
}

export interface VerifyRangeProofInputs {
  proof: Uint8Array;
  commitment: Uint8Array;
  valBase: Uint8Array;
  randBase: Uint8Array;
  bits?: number;
}

const RANGE_PROOF_WASM_URL = "https://unpkg.com/@distributedlab/aptos-wasm-bindings@0.2.4/aptos-wasm-bindings-bg.wasm";

/**
 * Generate range Zero Knowledge Proof
 *
 * @param opts.v The value to create the range proof for
 * @param opts.r A vector of bytes representing the blinding scalar used to hide the value.
 * @param opts.valBase A vector of bytes representing the generator point for the value.
 * @param opts.randBase A vector of bytes representing the generator point for the randomness.
 * @param opts.bits Bits size of value to create the range proof
 */
export async function generateRangeZKP(opts: RangeProofInputs) {
  await initWasm(RANGE_PROOF_WASM_URL);
  const proof = rangeProof(opts.v, opts.r, opts.valBase, opts.randBase, opts.bits ?? 32);

  return {
    proof: proof.proof(),
    commitment: proof.comm(),
  };
}

/**
 * Verify range Zero Knowledge Proof
 *
 * @param opts.proof A vector of bytes representing the serialized range proof to be verified.
 * @param opts.commitment A vector of bytes representing the Pedersen commitment the range proof is generated for.
 * @param opts.valBase A vector of bytes representing the generator point for the value.
 * @param opts.randBase A vector of bytes representing the generator point for the randomness.
 * @param opts.bits Bits size of the value for range proof
 */
export async function verifyRangeZKP(opts: VerifyRangeProofInputs) {
  await initWasm(RANGE_PROOF_WASM_URL);

  return verifyProof(opts.proof, opts.commitment, opts.valBase, opts.randBase, opts.bits ?? 32);
}
```

So, just place this at the very top of your app

```typescript
import { RangeProofExecutor } from '@aptos-labs/ts-sdk'

RangeProofExecutor.setGenerateRangeZKP(generateRangeZKP);
RangeProofExecutor.setVerifyRangeZKP(verifyRangeZKP);
```

For the native apps:

Generate `android` and `ios` bindings [here](https://github.com/distributed-lab/aptos-wasm-bindings) and integrate in your app as you please.

And the last, but not the least important part:

VC implements the Pollard's Kangaroo method for solving the discrete logarithm problem (DLP)
on the Ristretto curve. This method is particularly effective for finding discrete logarithms
within a known interval.

The implementation is inspired by the work of Daniel J. Bernstein and Tanja Lange in
"Computing small discrete logarithms faster" (2012), which discusses methods to accelerate
the computation of discrete logarithms in small intervals using precomputed tables.
[Source](https://cr.yp.to/dlog/cuberoot-20120919.pdf)

So we also need to init decryption for that:

```ts
import initWasm, {
  create_kangaroo,
  type WASMKangaroo as _WASMKangaroo,
} from "@distributedlab/aptos-wasm-bindings/pollard-kangaroo";

const POLLARD_KANGAROO_WASM_URL =
  "https://unpkg.com/@distributedlab/aptos-wasm-bindings/pollard-kangaroo/aptos_pollard_kangaroo_wasm_bg.wasm";

export type WASMKangaroo = _WASMKangaroo;

export async function createKangaroo(
  tableMap: {
    file_name: string;
    s: string[];
    slog: string[];
    table: {
      point: string;
      value: string;
    }[];
  },
  n: bigint,
  w: bigint,
  r: bigint,
  bits: number,
) {
  await initWasm({ module_or_path: POLLARD_KANGAROO_WASM_URL });

  return create_kangaroo(tableMap, n, w, r, bits);
}
```

[//]: # (TODO: update to 16->32->48 usage)
and place this at the top of your app:

```ts
const init = async () => {
  const [table16, table32, table48] = await Promise.all([
    loadTableMapJSON(
      "https://raw.githubusercontent.com/distributed-lab/pollard-kangaroo-plus-testing/refs/heads/tables/output_8_8000_16_64.json",
    ),
    loadTableMapJSON(
      "https://raw.githubusercontent.com/distributed-lab/pollard-kangaroo-plus-testing/refs/heads/tables/output_2048_4000_32_128.json",
    ),
    loadTableMapJSON(
      "https://raw.githubusercontent.com/distributed-lab/pollard-kangaroo-plus-testing/refs/heads/tables/output_65536_40000_48_128.json",
    ),
  ]);

  const kangarooWasm16 = await createKangaroo(table16, 8000n, 8n, 64n, 16);
  const kangarooWasm32 = await createKangaroo(table32, 4000n, 2048n, 128n, 32);
  const kangarooWasm48 = await createKangaroo(table48, 40_000n, 65536n, 128n, 48);

  TwistedElGamal.setDecryptionFn(async (pk) => kangarooWasm16.solve_dlp(pk));
}
```

For the native apps, you could generate `android` and `ios` bindings [here](https://github.com/distributed-lab/aptos-wasm-bindings) to use instead of WASM

---

Firstly, let's define aptos client

```typescript
const APTOS_NETWORK: Network = NetworkToNetworkName[Network.TESTNET];
const config = new AptosConfig({ network: APTOS_NETWORK });
export const aptos = new Aptos(config);
```

### Create Decryption Key (DK)

To interact with veiled token user must create a [unique key pair](/en/build/smart-contracts/veiled-coin#veiled-coin-store).

Generate new:

```typescript
const dk = TwistedEd25519PrivateKey.generate();
```

Or import existed one:

```typescript
const dk = new TwistedEd25519PrivateKey("0x...");
```

Also you could derive it using your `signature`:

```typescript
const user = Account.generate()

const signature = user.sign(TwistedEd25519PrivateKey.decryptionKeyDerivationMessage);

const dk = TwistedEd25519PrivateKey.fromSignature(signature);
```

Get encryption key:

```typescript
const encryptionKey = dk.publicKey()
const encryptionKeyHex = encryptionKey.toString()
```

### Register

To interact with veiled tokens, a user has to [register](/en/build/smart-contracts/veiled-coin#register) their encryption key (EK) in contracts

```typescript
const user = Account.generate()
const userDecryptionKey = TwistedEd25519PrivateKey.generate()

const TOKEN_ADDRESS = "0x..."

const userRegisterVBTxBody = await aptos.veiledCoin.registerBalance({
  sender: user.accountAddress,
  tokenAddress: TOKEN_ADDRESS,
  publicKey: userDecryptionKey.publicKey()
});

const txResponse = await aptos.signAndSubmitTransaction({ signer: user, transaction: userRegisterVBTxBody });

const txReceipt = await aptos.waitForTransaction({ transactionHash: txResponse.hash });

console.log(txReceipt);
```

this will check if user has already registered with token.

```typescript
const isRegistered = await aptos.veiledCoin.hasUserRegistered({
  accountAddress: user.accountAddress,
  tokenAddress: TOKEN_ADDRESS,
});
```

### Deposit (Veil)

Let's say you already have tokens.

This will deposit them to your veiled balance

```typescript

const DEPOSIT_AMOUNT = 5n;
const depositTx = await aptos.veiledCoin.deposit({
  sender: user.accountAddress,
  tokenAddress: TOKEN_ADDRESS,
  amount: DEPOSIT_AMOUNT,
});
const txResponse = await aptos.signAndSubmitTransaction({ signer: user, transaction: depositTx });

const txReceipt = await aptos.waitForTransaction({ transactionHash: txResponse.hash });

console.log(txReceipt);
```

### Get user's balance

Let's check user's balance after deposit.

You could do that by using `aptos.veiledCoin.getBalance` method:

```typescript
const userVeiledBalance = await aptos.veiledCoin.getBalance({ accountAddress: user.accountAddress, tokenAddress: TOKEN_ADDRESS });
```

This method returns you the user's [`pending` and `actual`](/en/build/smart-contracts/veiled-coin#veiled-coin-store) veiled balances, to [decrypt](/en/build/smart-contracts/veiled-coin#encryption-and-decryption) them, you can use `VeiledAmount` class

```typescript
import { VeiledAmount, Account, TwistedEd25519PrivateKey } from '@aptos-labs/ts-sdk'

const getBalances = async (accountAddress: string, decryptionKey: TwistedEd25519PrivateKey, tokenAddress: string) => {
  const userVeiledBalance = await aptos.veiledCoin.getBalance({ accountAddress, tokenAddress });

  const [veiledAmountPending, veiledAmountActual] = await Promise.all([
    VeiledAmount.fromEncrypted(userVeiledBalance.pending, decryptionKey),
    VeiledAmount.fromEncrypted(userVeiledBalance.actual, decryptionKey)
  ])

  return {
    pending: {
      amount: veiledAmountPending.amount,
      amountChunked: veiledAmountPending.amountChunked,
      amountEncrypted: veiledAmountPending.amountEncrypted,
    },
    actual: {
      amount: veiledAmountActual.amount,
      amountChunked: veiledAmountActual.amountChunked,
      amountEncrypted: veiledAmountActual.amountEncrypted,
    },
  }
}
```

### Rollover

After you deposited to user's veiled balance, you can see, that he has, for instance `5n` at his `pending` balance, and `0n` at his `actual` balance.

Since user can't operate with `pending` balance, you could [rollover](/en/build/smart-contracts/veiled-coin#rollover-pending-balance) it to `actual` one.

And you can do that, by using `aptos.veiledCoin.rolloverPendingBalance`.

<Callout type="warning">
  Important note, that user's actual balance need to be [normalized](/en/build/smart-contracts/veiled-coin#normalization) before `rollover` operation.
</Callout>

To cover [normalization](#normalization) & `rollover` simultaneously, you could use `aptos.veiledCoin.safeRolloverPendingVB`.

```typescript
const rolloverTxPayloads = await aptos.veiledCoin.safeRolloverPendingVB({
  sender: user.accountAddress,
  tokenAddress: TOKEN_ADDRESS,
  withFreezeBalance: false,
  decryptionKey: decryptionKey,
});

aptos.transaction.batch.forSingleAccount({
  user,
  data: rolloverTxPayloads,
});
```

After that you could check user's balance, his `pending` balance should be empty, and `actual` is `5n`.

---

### Normalization

Usually you don't need to explicit call [normalization](/en/build/smart-contracts/veiled-coin#normalization-1)

In case you want to:

Check veiled balance is normalized

```typescript
const isBalanceNormalized = await aptos.veiledCoin.isUserBalanceNormalized({
  accountAddress: user.accountAddress,
  tokenAddress: TOKEN_ADDRESS,
});
```

and normalize once need

```typescript
const balances = await getBalances(user.accountAddress.toString(), myDecryptionKey, TOKEN_ADDRESS);

const normalizeTx = await aptos.veiledCoin.normalizeUserBalance({
  tokenAddress: TOKEN_ADDRESS,
  decryptionKey: myDecryptionKey,
  unnormilizedEncryptedBalance: balances.actual.amountEncrypted,
  balanceAmount: balances.actual.amount,
  sender: user.accountAddress,
});

const txResponse = await aptos.signAndSubmitTransaction({ signer: user, transaction: normalizeTx });

const txReceipt = await aptos.waitForTransaction({ transactionHash: txResponse.hash });
```

<Callout type='warning'>
  The contract will revert if you try to normalize the normalized balance.
</Callout>

### Withdraw

Now, since we have funds in our `actual` balance, let's try to [withdraw](/en/build/smart-contracts/veiled-coin#unveil) some

```typescript
const balances = await getBalances(user.accountAddress.toString(), decryptionKey, TOKEN_ADDRESS);

const WITHDRAW_AMOUNT = 1n;
const withdrawTx = await aptos.veiledCoin.withdraw({
  sender: user.accountAddress,
  tokenAddress: TOKEN_ADDRESS,
  decryptionKey: decryptionKey,
  encryptedActualBalance: balances.actual.amountEncrypted,
  amountToWithdraw: WITHDRAW_AMOUNT,
});

const txResponse = await aptos.signAndSubmitTransaction({ signer: user, transaction: withdrawTx });

const txReceipt = await aptos.waitForTransaction({ transactionHash: txResponse.hash });

console.log(txReceipt);
```

### Transfer

For [transfer](/en/build/smart-contracts/veiled-coin#fully-veiled-transfer) you need to know recipient's encryption key and `aptos` account address

<Callout type="warning">
  Encryption key is now an `Account` address or public key, you need a specifically defined in Veiled Coins standard encryption key stored on-chain. (The same key you could get by calling `decryptionKey.publicKey())`
</Callout>

Let's say you have encryption key hex, lets define EncryptionKey for our operations

```typescript
const recipientEncryptionKeyHex = "0x..."
const recipientEncryptionKey = new TwistedEd25519PublicKey(recipientEncryptionKeyHex)
```

```typescript
const myBalance = await getBalances(user.accountAddress.toString(), myDecryptionKey, TOKEN_ADDRESS);
const recipientAccountAddress = "0x..."

const TRANSFER_AMOUNT = 2n;
const transferTx = await aptos.veiledCoin.transferCoin({
  sender: user.accountAddress,
  senderDecryptionKey: myDecryptionKey,
  recipientEncryptionKey: recipientEncryptionKey,
  encryptedActualBalance: myBalance.actual.amountEncrypted,
  amountToTransfer: TRANSFER_AMOUNT,
  tokenAddress: TOKEN_ADDRESS,
  recipientAddress: recipientAccountAddress,
});

const txResponse = await aptos.signAndSubmitTransaction({ signer: user, transaction: transferTx });

const txReceipt = await aptos.waitForTransaction({ transactionHash: txResponse.hash });

console.log(txReceipt);
```

Basically, your transfer could include a global auditor, which you can get by

```typescript
const [address] = await aptos.veiledCoin.getGlobalAuditor();
const globalAuditorAddress = address.toString();
```

The global auditor can be `None` (optional feature). But if it's set, it will be included into the auditor list as the first element automatically.

If you want to add more auditors to your transfer, you can use

```typescript
const AUDITOR = TwistedEd25519PrivateKey.generate();

const myBalance = await getBalances(user.accountAddress.toString(), myDecryptionKey, TOKEN_ADDRESS);
const recipientAccountAddress = "0x..."

const TRANSFER_AMOUNT = 2n;
const transferTx = await aptos.veiledCoin.transferCoin({
  sender: user.accountAddress,
  senderDecryptionKey: myDecryptionKey,
  recipientEncryptionKey: recipientEncryptionKey,
  encryptedActualBalance: myBalance.actual.amountEncrypted,
  amountToTransfer: TRANSFER_AMOUNT,
  tokenAddress: TOKEN_ADDRESS,
  recipientAddress: recipientAccountAddress,
  auditorEncryptionKeys: [AUDITOR.publicKey()],
});

const txResponse = await aptos.signAndSubmitTransaction({ signer: user, transaction: transferTx });

const txReceipt = await aptos.waitForTransaction({ transactionHash: txResponse.hash });
```

### key rotation

To do [key rotation](/en/build/smart-contracts/veiled-coin#rotate-encryption-key), you need to create new decryption key and use `aptos.veiledCoin.rotateVBKey`

<Callout type="warning">
  But keep in mind, that to avoid `front-running` attacks you have to `freeze` your pending balance with `rollover_pending_balance` function, to do so, you can use static `VeiledCoin.safeRotateVBKey` method, which simplify flow for you.
</Callout>

```typescript
const balances = await getBalances(user.accountAddress.toString(), myDecryptionKey, TOKEN_ADDRESS);

const NEW_DECRYPTION_KEY = TwistedEd25519PrivateKey.generate();
const keyRotationAndUnfreezeTxResponse = await VeiledCoin.safeRotateVBKey(aptos, user, {
  sender: user.accountAddress,

  currDecryptionKey: currentDecryptionKey,
  newDecryptionKey: NEW_DECRYPTION_KEY,

  currEncryptedBalance: balances.actual.amountEncrypted,

  withUnfreezeBalance: true, // if you want to unfreeze balance after
  tokenAddress: TOKEN_ADDRESS,
});

// save: new decryption key
console.log(NEW_DECRYPTION_KEY.toString());

// check new balances
const newBalance = await getBalances(user.accountAddress.toString(), NEW_DECRYPTION_KEY, TOKEN_ADDRESS);

console.log(newBalance.pending.amount);
console.log(newBalance.actual.amount);
```
